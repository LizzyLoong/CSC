## 扑克牌消除
### 题目描述
从一副扑克牌中随机抽取n张牌组成一个序列，规定连续3张相同牌号的卡牌可以消除，剩余卡牌按照当前顺序重新合并成新的序列后继续消除，   
重复以上步骤直到无法消除。最后请输出结束后剩余的卡牌序列   
注：存在连续4张相同牌号的情况，消除后剩余一张   
### 解答要求
时间限制：C/C++：1000ms 其他语言：2000ms
内存限制：C/C++：256MB 其他语言：512MB
### 输入
第一行一个正整数n（1≤n≤52）表示卡牌的数量，
第二行一个字符串，以空格分隔代表卡牌号序列，牌号仅包含2-10，A，J，Q，K
### 输出
一个字符串，打印最终结束后的卡牌号序列，卡牌号以空格分割，如果最终没有卡牌剩余输出0。
### 样例1
```
复制 输入：10
          3 A 2 2 2 A A 7 7 7
复制 输出：3
解释： 第一轮三个卡牌2连续消除，剩余卡牌号序列为3 A A A 7 7 7
      第二轮三个卡牌A连续消除，剩余卡牌号序列为3 7 7 7
      第三轮三个卡牌7连续消除，剩余卡牌号序列为3
      输出卡牌号序列：3
```
### 样例2
```
复制 输入：6
          2 3 3 3 2 2
复制 输出：0
解释： 第一轮三个卡牌3连续消除，剩余卡牌号序列为2 2 2
      第二轮三个卡牌2连续消除，无剩余卡牌
      输出卡牌号序列：0
```






## 云上故障逃生
### 题目描述
在云上多个业务节点之选择最快的逃生节点集，并考虑每个节点的剩余业务容量。有一个网络时延表，表示每个节点到其他节点的通信延迟;   
还有一个剩余业务客量表，表示每个节点的剩余业务容量。   
在一个节点故障时，需要选择一个或多个逃生节点，确保逃生路径的时延最小，并且逃生节点集各节点剩余容量的总和足够容纳故障节点的业务量   
当故障节点与多个节点最短距离相同，优先选择编号较小的节点容灾，如果逃生节点集中多个节点最短距离相同时，按编号从小到大的顺序排列。   
### 解答要求
时间限制：C/C++：1000ms 其他语言：2000ms
内存限制：C/C++：256MB 其他语言：512MB
### 输入
第一行n表示云上业务节点数。2<=n<=10000，节点编号从0开始，依次递增；   
第2行到1+n行表示业务节点间的网络时延矩阵表delayMatrix。delayMatrix[i][j]表示节点i到节点j的通信时延   
1)如果节点i和节点j之间没有直接相连的边，则delayMatrix[i][j]=-1，第i个节点和它自己也没有边，所以delayMatrix[i][i]=-1   
2)节点间有边时延范围为1<=delayMatrix[i][j]=1000，矩阵元素间使用空格分割   
另，输入保证delayMatrix[i][j]==delayMatrix[j][i]   
第2+n行表示各业务节点的剩余容量表remainingCapacity，其中remainingCapacity[i]表示节点i的剩余业务容量，业务量的范围1<=remainingCapacity[i]<=100。数组元素间使用空格分割    
第3+n行表示故障业务节点编号faultyNode，表示发生故障的节点，取值范围为0<=faultyNode<=n-1   
