## 扑克牌消除
### 题目描述
从一副扑克牌中随机抽取n张牌组成一个序列，规定连续3张相同牌号的卡牌可以消除，剩余卡牌按照当前顺序重新合并成新的序列后继续消除，   
重复以上步骤直到无法消除。最后请输出结束后剩余的卡牌序列   
注：存在连续4张相同牌号的情况，消除后剩余一张   
### 解答要求
时间限制：C/C++：1000ms 其他语言：2000ms
内存限制：C/C++：256MB 其他语言：512MB
### 输入
第一行一个正整数n（1≤n≤52）表示卡牌的数量，
第二行一个字符串，以空格分隔代表卡牌号序列，牌号仅包含2-10，A，J，Q，K
### 输出
一个字符串，打印最终结束后的卡牌号序列，卡牌号以空格分割，如果最终没有卡牌剩余输出0。
### 样例1
```
复制 输入：10
          3 A 2 2 2 A A 7 7 7
复制 输出：3
解释： 第一轮三个卡牌2连续消除，剩余卡牌号序列为3 A A A 7 7 7
      第二轮三个卡牌A连续消除，剩余卡牌号序列为3 7 7 7
      第三轮三个卡牌7连续消除，剩余卡牌号序列为3
      输出卡牌号序列：3
```
### 样例2
```
输入：6
          2 3 3 3 2 2
输出：0
解释： 第一轮三个卡牌3连续消除，剩余卡牌号序列为2 2 2
      第二轮三个卡牌2连续消除，无剩余卡牌
      输出卡牌号序列：0
```






## 云上故障逃生
### 题目描述
在云上多个业务节点之选择最快的逃生节点集，并考虑每个节点的剩余业务容量。有一个网络时延表，表示每个节点到其他节点的通信延迟;   
还有一个剩余业务客量表，表示每个节点的剩余业务容量。   
在一个节点故障时，需要选择一个或多个逃生节点，确保逃生路径的时延最小，并且逃生节点集各节点剩余容量的总和足够容纳故障节点的业务量   
当故障节点与多个节点最短距离相同，优先选择编号较小的节点容灾，如果逃生节点集中多个节点最短距离相同时，按编号从小到大的顺序排列。   
### 解答要求
时间限制：C/C++：1000ms 其他语言：2000ms
内存限制：C/C++：256MB 其他语言：512MB
### 输入
第一行n表示云上业务节点数。2<=n<=10000，节点编号从0开始，依次递增；   
第2行到1+n行表示业务节点间的网络时延矩阵表delayMatrix。delayMatrix[i][j]表示节点i到节点j的通信时延   
1)如果节点i和节点j之间没有直接相连的边，则delayMatrix[i][j]=-1，第i个节点和它自己也没有边，所以delayMatrix[i][i]=-1   
2)节点间有边时延范围为1<=delayMatrix[i][j]=1000，矩阵元素间使用空格分割   
另，输入保证delayMatrix[i][j]==delayMatrix[j][i]   
第2+n行表示各业务节点的剩余容量表remainingCapacity，其中remainingCapacity[i]表示节点i的剩余业务容量，业务量的范围1<=remainingCapacity[i]<=100。数组元素间使用空格分割  
第3+n行表示故障业务节点编号faultyNode，表示发生故障的节点，取值范围为0<=faultyNode<=n-1   
第4+n行表示受损业务节点需要迁移的业务量，受损业务量的范围为（0-1000]   
### 输出
返回符合条件的逃生路径节点编号列表（以单空格间隔），当所有节点都不够故障业务节点容灾的时候，输出所有容灾节点   
### 样例1
```
输入：4
          -1 5 -1 8
          5 -1 1 3
          -1 1 -1 4
          8 3 4 -1
          10 20 15 25
          2
          12
输出：1
解释： 根据第二行到第1+n行输入的矩阵画出图
      在给定的测试用例中，假设节点2发生故障，需要迁移业务量为12
      节点2到其他节点的最短路径如下：
          |-------|--0--|--1--|--2--|--3--|
          |minDist|--6--|--1--|-无穷-|--4--|
      离故障节点2时延排序为1,3,0,故障节点要转移的业务量为12,而节点1的可容灾余量为20,足够容纳故障节点2的受灾业务，所以该测试用例的期望输出是1

```
